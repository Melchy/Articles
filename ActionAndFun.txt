K tomu co to dela:
C# umoznuje ulozit metody do promenych. Ukazka zde https://repl.it/repls/StudiousGracefulQuadrilateral (snad ten odkaz funguje). Dokumentace k delegatum je [zde](https://docs.microsoft.com/cs-cz/dotnet/csharp/programming-guide/delegates/using-delegates)

Problem delegatu ale je ze je nemuzete definovat uvnitr metody neco jako 
```csharp
public static void Main (string[] args) {
   delegate void Del(string message); //toto neni validni syntax
   Del handler = DelegateMethod;
}
```
kdyz tedy chcete ulozit metodu do promene musite vzdy vytvorit novou tridu ktera definuje jako propertu public delegata. Priklad https://repl.it/repls/IroncladEachVirtualmemory.

Jak muzete vydet tak pozuiti delegatu je pomerne nepekne. Dale se to zhorsuje tim ze byseme museli vytvaret tridy pro vsechny typy delegatu. Napr.
`public delegate void Del(string message); `
`public delegate void Del(int message); `
`public delegate string Del(); `
atd. pro vsechny kombinace typu.

Tvurci C# ale byly chytrejsi a uz za nas tuto praci udelali vytvorili tridy s nazvem:
Action a Func<T>. Kde action definuje tridu obsahujici delegata ktery ma return typ void a Func<T> definuje tridu ktera obsahuje delegata s navratovym typem <T>. Ukazka trivialni implementace: https://repl.it/repls/PersonalInfamousLead.

C# take definuje spoustu overloadu tech dvou trid napr. Action, Action<T1>, Action<T1,T2>, Action<T1,T2, T3> a tak dale az k Action<T1,....T16>. Tyto vsechny tridy obaluji delegaty ktere nic nevraci a berou jeden, dvat, tri az sestnact parametru.

Stejne tak C# definuje Func. Func<TResult>, Func<T1,TResult>, Func<T1,T2, TResult> ... Func<T1,T2, ..... T16, TResult>. Coz jsou metody ktere berou parametry T1 az T16 a vraci TResult. 

Dokumentace k temto tridam [zde](https://docs.microsoft.com/cs-cz/dotnet/api/system.action-1?view=netframework-4.8) a [zde](https://docs.microsoft.com/cs-cz/dotnet/api/system.func-2?view=netframework-4.8).

No a ted uz muzeme prejit k tomu co jsem napsal ja:
nejdrive rozeberme jak funguje toto:
`sut.Invoking(x => x.Run(JsonConvert.SerializeObject(udpDto)))`
fluent assetions definuje metodu `Invoking` ktera vypada nasledovne:

`public static void Invoking<T>(this T classThatContainsMethod, Action<T> action).`

vsimnete si generickeho parametru v this. Toto zpusobi ze tato extension metoda se da zavolat na kazde tride. Muzeme tedy udelat napr. `int x = 1; x.Invoking(...); nebo string x = "ASd"; x.Invoking(...);`.

Druhy parametr v Invoking je Action<T>. Coz je tedy metoda ktera ma jako prvni parametr tridu kterou jsme predali prvnim parametrem.

int x = 1;
x.Invoking(int x => x.ToString()) // do druheho parametru jsme predali metodu ktera jako prvni parametr bere int predany v prvnim parametru.

string x = 1;
x.Invoking(string x => x.ToString()) // do druheho parametru jsme predali metodu ktera jako prvni parametr bere string predany v prvnim parametru.

Kdyz potom napiseme x.Invoking(x=> x.ToString()).ShouldThrow<Exception>(). Tak by implementace mohla vypadat nasledovne:

public static void Invoking<T>(this T classThatContainsMethod, Action<T> action){
  try {
     action(classThatContainsMethod); // vezmeme predanou metodu a jako parametr ji dame prvni argument.
  }catch(Exception e){
     //nejaky dalsi kod pokud se vhodi exception
  }
}

Pokud jste dosel az sem tak muzete pochipit jak funguje to co jsem napsal ja:

Action sutCall = () => sut.Run(JsonConvert.SerializeObject(udpDto));

timto jsme ulozili volani naseho sut do metody ktera nebere zadne parametry fluent assertions tedy muze jednoduse udelat:

try{
  sutCall();
}catch..
a nepotrebuje predavat sut (ten je jiz ulozeny v te action).

muzeme tedy napsat

sutCall.ShouldThrow()...